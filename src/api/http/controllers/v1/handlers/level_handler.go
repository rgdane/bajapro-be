// level_handler.go - generated by api:generate level

package handlers

import (
	"fmt"
	"jk-api/api/http/controllers/v1/dto"
	"jk-api/api/http/controllers/v1/mapper"
	"jk-api/internal/database/models"
	"jk-api/pkg/services/v1"
)

type LevelHandler struct {
	Service services.LevelService
}

func NewLevelHandler(service services.LevelService) *LevelHandler {
	return &LevelHandler{Service: service}
}

func (h *LevelHandler) CreateLevelHandler(input *dto.CreateLevelDto) (*dto.LevelResponseDto, error) {
	db := h.Service.GetDB().Begin()
	committed := false
	defer func() {
		if r := recover(); r != nil {
			db.Rollback()
			panic(r) // bubble up panic
		}
		if !committed {
			db.Rollback()
		}
	}()

	levelService := h.Service.WithTx(db)

	payload, err := mapper.CreateLevelDtoToModel(input)
	if err != nil {
		return nil, err
	}

	createdData, err := levelService.CreateLevel(payload)
	if err != nil {
		return nil, err
	}

	if err := db.Commit().Error; err != nil {
		return nil, err
	}
	committed = true

	return mapper.LevelModelToResponseDto(createdData)
}

func (h *LevelHandler) UpdateLevelHandler(id int64, input *dto.UpdateLevelDto) (*models.Level, error) {
	db := h.Service.GetDB().Begin()
	committed := false
	defer func() {
		if r := recover(); r != nil {
			db.Rollback()
			panic(r)
		}
		if !committed {
			db.Rollback()
		}
	}()

	levelService := h.Service.WithTx(db)

	payload, err := mapper.UpdateLevelDtoToModel(input)
	if err != nil {
		return nil, err
	}

	updatedData, err := levelService.UpdateLevel(id, payload)
	if err != nil {
		return nil, err
	}

	if err := db.Commit().Error; err != nil {
		return nil, err
	}
	committed = true

	return updatedData, nil
}

func (h *LevelHandler) DeleteLevelHandler(id int64) error {
	db := h.Service.GetDB().Begin()
	committed := false
	defer func() {
		if r := recover(); r != nil {
			db.Rollback()
			panic(r)
		}
		if !committed {
			db.Rollback()
		}
	}()

	levelService := h.Service.WithTx(db)

	if err := levelService.DeleteLevel(id); err != nil {
		return err
	}

	if err := db.Commit().Error; err != nil {
		return err
	}
	committed = true

	return nil
}

func (h *LevelHandler) GetLevelByIDHandler(id int64, filter dto.LevelFilterDto) (*models.Level, error) {
	return h.Service.GetLevelByID(id, filter)
}

func (h *LevelHandler) GetAllLevelsHandler(filter dto.LevelFilterDto) ([]models.Level, int64, error) {
	data, err  := h.Service.GetAllLevels(filter)
	if err != nil {
		return nil, 0, err
	}
	var total int64
	db := h.Service.GetDB()
	if filter.Name != "" {
		db = db.Where("name ILIKE ?", "%"+filter.Name+"%")
	}
	if filter.ShowDeleted {
		db = db.Unscoped().Where("deleted_at IS NOT NULL")
	}
	if err := db.Model(&models.Level{}).Count(&total).Error; err != nil {
		return nil, 0, err
	}

	return data, total, nil
}

func (h *LevelHandler) BulkCreateHandler(input *dto.BulkCreateLevelDto) ([]*models.Level, error) {
	var levels []*models.Level

	for _, createDto := range input.Data {
		level, err := mapper.CreateLevelDtoToModel(createDto)
		if err != nil {
			return nil, err
		}
		if level != nil {
			levels = append(levels, level)
		}
	}

	return h.Service.BulkCreateLevels(levels)
}

func (h *LevelHandler) BulkUpdateHandler(input *dto.BulkUpdateLevelDto) ([]*models.Level, error) {
	updates, err := mapper.UpdateLevelDtoToModel(input.Data)
	if err != nil {
		return nil, fmt.Errorf("failed to map update data: %w", err)
	}

	if len(updates) == 0 {
		return nil, fmt.Errorf("update data cannot be empty")
	}

	err = h.Service.BulkUpdateLevels(input.IDs, updates)
	if err != nil {
		return nil, fmt.Errorf("failed to bulk update levels: %w", err)
	}

	updatedLevels, err := h.Service.GetLevelsByIDs(input.IDs)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve updated levels: %w", err)
	}
	return updatedLevels, nil
}

func (h *LevelHandler) BulkDeleteHandler(input *dto.BulkDeleteLevelDto) error {
	db := h.Service.GetDB().Begin()
	committed := false
	defer func() {
		if r := recover(); r != nil {
			db.Rollback()
			panic(r)
		}
		if !committed {
			db.Rollback()
		}
	}()

	levelService := h.Service.WithTx(db)

	if err := levelService.BulkDeleteLevels(input.IDs); err != nil {
		return err
	}

	if err := db.Commit().Error; err != nil {
		return err
	}
	committed = true

	return nil
}
